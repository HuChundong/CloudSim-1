% %This is a very basic article template.
% %There is just one section and two subsections.
\documentclass[10pt, conference, compsocconf]{IEEEtran}
\usepackage{threeparttable}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}

\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\setcounter{page}{1}
\pagestyle{plain}
\pagenumbering {arabic}

\title{A Simulated Annealing Algorithm for Energy Efficient Virtual Machine Placement}


% author names and affiliations use a multiple column layout for up to two
% different affiliations

\author{\IEEEauthorblockN{Yongqiang Wu, Maoling Tang and Warren
Fraser} \IEEEauthorblockA{Queensland University of Technology\\
2 George Street, Brisbane, QLD 4001, Australia\\
\{yongqiang.wu\}@connect.qut.edu.au,\{m.tang;w.fraser\}@qut.edu.au\\
}
}


% make the title area
\maketitle


\begin{abstract}
Virtual machine placement algorithms are the key issue for the energy-efficient
resource management in the data center environment. The placement problem is
often modeled as the bin packing problem. Due to the NP-hard nature of the
problem, there are only heuristic solutions, among which First Fit and Best Fit
algorithms have been used widely and have generally good results. However, their
simplicity leaves room for further improvement. In this paper we propose an
algorithm based on the simulated annealing theory, which enables continuous
improvement from any feasible state. This is the first published
attempt of using SA based algorithms to solve the VM placement problem to optimize
energy efficiency. Experiment results show that this
algorithm can generate better results, saving up to 25 percentage more energy
than First Fit Decreasing in an acceptable time frame.

\end{abstract}

\begin{IEEEkeywords}
simulated annealing; virtual machine placement; energy optimization;

\end{IEEEkeywords}

\section{Introduction}
% no \IEEEPARstart
Energy saving in data centers has become an increasingly urgent problem when
they have been growing very large, consuming tremendous amounts of
electricity. It is quoted by Judge~\cite{judge08} that the capacity demand of
data centers has been increasing by 12 percent annually with the electricity prices
increasing by 4.4 percent per year, and the electricity cost in data centers
in USA is estimated at \$3.3 billion in 2008. Virtualization technology like
VmWare~\cite{vmware01} and Xen~\cite{xen01}, which consolidate multiple logic
servers into a smaller number of physical machines has been used to make better
use of hardware and save energy. Instead of having its own dedicated physical host, each logic
server runs on the Virtual Machine (VM) hosted on the Physical Machine (PM).
Besides the static consolidation, the live VM migration technique has also been
applied to further reduce energy consumption by migrating VMs to fewer physical
nodes when workloads of the VMs are lighter.

In both static and dynamic assignment of the VMs to the PMs, the algorithms of
assigning the VMs to the PMs are the key issue, which may affect the optimized
objective like energy conservation significantly by different placement
decisions. Ideally, there is a complete solution, which provides the best result
of the optimized objective. However, this is an NP-hard problem which has
$M^{N}$ ways of placement, where N is the physical node number and M the virtual machine
number. Therefore, heuristic solutions are usually used to solve this type of
problem, as shown in the literature
~\cite{verma08}~\cite{verma09}~\cite{wood09}~\cite{kusic09}~\cite{stillwell10}~\cite{yao80}.

 First Fit Decreasing (FFD), Best Fit (BF) for Bin Packing problems are the
 well known types of the heuristic methods. In FFD algorithm, the balls are
 sorted by size in the descending order - largest first. The balls are then packed in the first
 available bin that can accommodate them. The bins are also ordered based on
 their efficiency, with the most efficient one in the head of the list. They
 have low complexity, good scalability and generally good results in
 practice~\cite{yao80}. However, their main drawback is the over simplicity that
 overlooks the large amount of combinations among which there may
 be significantly better results. Furthermore, it only sorts the bins in one
 dimension. This will reduce their performance when the characteristics of other dimensions disrupt the
 ordering and undermine the fundamental optimization logic.

Best Fit has the poor performance in providing an overall placement, because it
only aims at finding the best placement for the current VM. This local
optimization strategy makes it perform poorly in the global VM assignment
solution.
However it has been used often in dynamic placement when only one or several VMs
need to be relocated at a time like in the
works~\cite{calheiros11}~\cite{beloglazov10}.

Genetic algorithms are optimization techniques inspired from natural
evolution processes~\cite{hertz00}, and  believed to be able to generate a
promising result after a certain number of generations, but there have not been very successful
attempts in tackling the VM machine placement problem so far to our best
knowledge.

In this paper, we propose the Simulated Annealing Virtual Machine Placement(SAVMP)
algorithm, which is based on simulated annealing theory, to solve this problem.
Simulated Annealing (SA) was proposed by Kirkpatrick et al~\cite{kirkpatrick83}
to be a general approach of solving some NP complete optimization
problems in a heuristic way.
The theory is based on the insightful analysis of connection between statistical
mechanics and multivariate or combinatorial optimization. The effectiveness of
SA comes from its extension of two basic heuristic techniques: 1) divide and
conquer approach; 2) iterative improvement scheme. It separates large changes
and small changes by allowing large changes in the objective function at high
temperatures while deferring small changes to low temperatures. It iteratively
moves the configuration by small steps from one state to another while
preventing from being stuck by allowing large changes at high temperatures.

The contributions of this paper are: we propose an algorithm based on the
simulation annealing methodoloy to solve the energy-efficient VM placement
problem; we design and perform plenties of tests to demonstrate the
superority of the proposed algorthim for the targeted problem over other
existing solutions in the term of the optimized objective.

To evaluate the performance of SAVMP, we compare the test results of it with
those of First Fit Decreasing and a random searching approach. Experiment results show that SAVMP has the better
performance at the cost of more time than FFD, outperforming FFD with 0-25
percent more energy saving; SAVMP is also better than the random searching
, which only performs well in small sized problems and is not
able to generate better results than FFD when the problem size is larger.

\section{Related Work}

Many researchers have proposed solutions to increase the energy efficiency of
the server clusters based on virtual machine technologies in data centers
~\cite{verma08}~\cite{verma09}~\cite{wood09}~\cite{kusic09}~\cite{stillwell10}.
Most of them make use of the ordering algorithms to generate the VM
placement. However, due to the non-trivial live VM migration cost, the First
Fit Decreasing (FFD) is not suitable to be used to re-map all the VMs to PMs every time interval.
For example, `pMapper' uses FFD to generate an initial assignment of VMs and later re-assign
VMs picked from PMs which violate resource constraints using Best Fit
~\cite{verma08}; in MFR algorithm~\cite{Bobroff07}, the prediction techniques are applied to deal
with the time varied demand pro-actively and FFD is applied according to the
predicted demand; Our work differs from theirs in that they use the FFD as
the basic algorithm to come up solutions to meet the resource requirement of the
dynamic VM workloads while conserving energy, but we are proposing an algorithm potential
to replace FFD or combine with FFD to generate a better VM placement.

Mishira et al~\cite{mashira11} point out the `anomalies' in some existing VM
packing algorithms, after observing some abnormal placement results of the
algorithms . They propose a vector based approach in order to
make use of different resources of PMs in a more proportional way. In comparison, our proposed approach aims at
optimization of the objective function rather than achieving the balanced usage
of different resources directly, although the results found by our methodology should be
able to use the resources in a reasonably balanced way, otherwise it would lead
to higher energy cost.

Besides the ordering placement algorithms, Constraint Programming (CP) , a
software technology for solving combinatorial problems especially in areas of
planning and scheduling~\cite{nakada09}, is also used to allocate resources on
PMs to VMs.
Entropy~\cite{hermenier09}, for example, formulates the VM resource allocation
problem firstly as a constraint satisfaction problem then solve it by a
constraint solver to get the optimization solution in a homogeneous PM
environment. In the first step of Entropy, it finds the minimum number of PMs,
and searches for a `best' migration configuration to the new state in the second
step.
Although CP is a complete method, it is used by Entropy in a heuristic way
because it probably cannot finish searching in the limited time. It has a
certain similarity to our proposed approach in that it can stop the searching at
any time and use the best result achieved so far. However, the main limitation
of Entropy lies in the assumption that all the PMs should be identical.

Genetic Algorithm (GA) has been used widely as an effective heuristic way of
solving NP-hard problems. It has also been applied in the VM placement problem
~\cite{nakada09}~\cite{campegiani09}.
However, in the published literature, there has not been much work in which it
performs very well in the resource allocation problem. Campegiani et
al~\cite{campegiani09} only used a small number of VMs and PMs in the evaluation
of their GA based solution , and Nakada et al~\cite{nakada09} did not use data to explain how well their
algorithm performed in their test environment. Therefore we cannot compare our proposed approach
with GA due to the lack of detail data about the GA application in the VM
placement problem.

A spation-temporal tradeoff technique has been proposed by Cardosa et
al~\cite{cardosa11} to improve energy efficiency in data processing application
cloud environment.
Their work adjusts jobs arrangement to conserve energy in two axis: space and
time. However, this technique is aimed at the private enterprise cloud
environment where the job execution time are allowed to be changed freely to
some extent.
In contrast, our work can apply both in private and public cloud environment
where the computing resources ususally should be provided at the exact time when
they are needed to ensure the service quality for many services like web portal
services.

Finally, SA is mentioned in Hser et al's work~\cite{hyser07} in which they designed a modified
Simulation Annealing solver to allocate VMs among PMs, but they did not provide
detail information about their SA based methodology. Kezam et al~\cite{kazem08}
used a modified SA to schedule tasks in the computing grid to optimize the
workspans of the tasks. Our work is different from Kezam et al's in that we are
aiming at the energy efficient VM placement in the data center environment and
our algorithm is specially designed for the targeted problem and can finish searching in a
 satisfactory time frame rather than a very long time in their work.

\section{Problem Formulation}
To formulate this problem we are dealing with in the mathematical form, let's
define\\
$N$ number of virtual machines\\
$M$	number of physical machines\\
$v_i$	the number $i$ virtual machine\\
$p_j$	the number $j$ physical machine\\
$vp_{ij}$	the binary value representing whether virtual machine $v_i$ is
assigned to physical node $p_j$\\
$V$	the set of $N$ virtual machines, namely ${v_1,v_2,...,v_N}$\\
$P$	the set of M physical machines, namely ${p_1,p_2,...,p_M}$\\
$u_j$	the percentage of CPU utilization of $p_j$\\
$e_j$	the energy consumption of $p_j$\\
$e_{max}^j$	the energy consumption of $p_j$ when $u_j$=100\%\\
$e_{idle}^j$	the energy consumption of $p_j$ when $u_j$=0\%\\
$v_{cpu}^i$	the CPU demand of $v_i$\\
$v_{mem}^i$ the RAM demand of $v_i$\\
$v_{net}^i$	the Network Bandwidth capacity of $v_i$\\
$p_{cpu}^j$	 the CPU capacity of  $p_j$\\
$p_{mem}^j$ the RAM capacity of  $p_j$\\
$p_{net}^i$	the Network Bandwidth capacity of $p_j$\\
$VP$	the assignment of $V$ to $P$, represented by


\begin{equation}\label{1}
    \left(
  \begin{array}{ccc}
    vp_{11} & \ldots & vp_{1M} \\
    \vdots & \ddots & \vdots \\
    vp_{N1} & \ldots & vp_{NM} \\
  \end{array}
\right)
\end{equation}\\
where\\
\begin{equation}\label{2}
    vp_{ij}=\Bigg\lbrace \begin{array}{cl}
     1, & if\, v_i\, is\, assigned\,to\, p_j \\
    0, & otherwise \\
    \end{array} \\
    1\leq i\leq N \, , \, 1\leq j\leq M
\end{equation}

 For a given assignment $VP$, the $CPU$ utilization of $p_j$ can be calculated by\\
 \begin{equation}\label{3}
 u_j=\frac{
\sum_{i=1}^Nv_{cpu}^i*vp_{ij}
 }{p_{cpu}^j} \\
\end{equation}
 The energy consumption of $p_j$ can be computed by the following
 equation~\cite{beloglazov10}:
\begin{equation}\label{4}
    e_j=\Bigg\lbrace \begin{array}{ll}
     0,& when \, \sum_{i=1}^Nvp_{ij}=0  \\
(e_{max}^j-e_{idle}^j)*\frac{u_j}{100}+e_{idle}^j,& otherwise\\
    \end{array} \\
\end{equation}

 When $\sum_{i=1}^Nvp_{ij} =0$, it means that no virtual machine is assigned to
 $p_j$, so it can be turned off and cost no energy.

 The objective of the research is to find an assignment $VP$ that minimizes \\
\begin{equation}\label{5}
\sum_{j=1}^Me_j  \\
\end{equation}
subject to: \\
\begin{equation}\label{6}
\forall i,\sum_{j=1}^Mvp_{ij}=1  \\
\end{equation}
\begin{equation}\label{7}
\forall j, \sum_{i=1}^Nv_{mem}^i*vp_{ij}\leq p_{mem}^j \\
\end{equation}
\begin{equation}\label{8}
\forall j, \sum_{i=1}^Nv_{cpu}^i*vp_{ij}\leq p_{cpu}^j \\
\end{equation}
\begin{equation}\label{9}
\forall j, \sum_{i=1}^Nv_{net}^i*vp_{ij}\leq p_{net}^j \\
\end{equation}
Constraint (6) means one virtual machine can only be assigned and should be
assigned to one physical machine; constraints (7,8,9) requires that the total
CPU, memory, or network resources assigned to the VMs of one PM cannot exceed
the respective capacities of the host. Here we implicitly assume that the
overall resources on the Physical Machines (PMs) are enough to accommodate the
guest virtual machines, so we can ensure every guest Virtual Machine (VM) can
have a host to run on.

If we traversed all the combinations of VMs with PMs, the complexity would be at
least $N^M$, so there will be no exact solution to the problem when $N$ and $M$
become a little larger. Therefore, we are going to deal with this problem via a
heuristic way.

\section{Algorithm description}

As the authors of SA suggested, there are basically four components in the
algorithm: 1) configuration of the system; 2) a generator of the new
configuration; 3) the objective function for the optimization problem; 4) a
schedule of the temperatures and length of times to evolve
~\cite{kirkpatrick83}. In SAVMP, the four components are clearly defined to
follow this methodology.

\subsection{Configuration of the problem}
The assignment of virtual machines $V$ to physical machines $P$ is the
configuration. Making use of constraint that one VM can only assigned to one PM,
and to reduce the number of variables and the searching space, we use an integer
array to represent the assignment rather than the matrix as in Equation~(1). 
\begin{equation}\label{10}
VM=\{vm_1,vm_2,\ldots,vm_i,\ldots,vm_{n}\} \\
\end{equation}
The index of the array is the VM number, and the value indexed by the VM number
in the array is the PM number to which the VM is assigned. For example, we have
10 VMs indexed from 1 to 10 and 3 PMs numbered from 1 to 3.
$VM=\{1,2,1,3,2,1,3,2,1,2\}$ means that $vm_1,vm_3,vm_6 \, $and$ \, vm_9$ are
assigned to $pm_1$; $vm_5,vm_8 \,$ and $\, vm_{10}$ are assigned to $pm_2$;$vm_4
\, and \, vm_7$ are assigned to $pm_3$.

\subsection{Generator of new configurations }
The aim of the algorithm is to search better configurations in term of objective
function, but the search space is very large. Which way is the economical path
toward better solutions? SA searches in the neighborhood states for
better results. At every evolution step, the configuration needs to be changed
into a new neighborhood state, so the configurations change slowly moving toward
better configurations. We define a new neighborhood state as the new VM
assignment array changed by picking a small random number (from 1 to 3 in this
implementation) of VMs and changing their host machines to randomly selected PMs
or swapping a pair of VM assignment.
These two types of rearrangement of VMs to create new configurations reflect the
basic operations of doing bin-packing to get a better result.

\subsection{ Acceptance criteria of new configurations}
While generating new configurations provides the candidate configurations, the
acceptance criteria decide which configuration becomes the next new state. In
the proposed algorithm, if a new configuration is feasible, namely satisfying all constraints
specified by Equation (6,7,8,9), and has lower energy consumption than the
previous state, it will be accepted as the new state.
The energy cost expressed in Equation (5) is computed for each state. To be
simple, during the energy computation, if a solution is found to be infeasible,
the energy value will be assigned a huge number, which will not pass the
acceptance criteria. Therefore the energy comparison is the only operation in
the acceptance decision. When the neighborhood searching gets into a stalemate, we
allow the new state to cost more energy than the previous one by a certain
amount, called $deivationEngergy$ in our algorithm, so the algorithm would not
be stuck in a local optimization.
The $deivationEngergy$ is decided by the temperature. We define it as:
\begin{equation}\label{11}
deivationEngergy=\max(e_{max}^j)*\frac{t_c}{t_0} \\
\end{equation}
where $t_c$ is the current temperature and $t_0$ is the initial temperature.
Hence at a high temperature, the energy increase by the next state can be
relatively large, but when the temperature is low, the energy of accepted states
will become stable.

\subsection{ Temperature Scheduling}
The temperature scheduling is a very important aspect in the simulation
annealing methodology, otherwise the quick quenching can lead to results far
from optimal~\cite{kirkpatrick83}. How many iterations are allowed at each
temperature and the range of temperature, for example, are the issues of
temperature scheduling.
However, the designing of the temperature scheduling is not detailed in the SA
methodology, but explained as through an empirical way. We tried several
settings and selected the best ones as the parameters of the scheduling as
follows.
The temperature starts from 1000 degree and reduces gradually to 0 by 5 degrees
each time, at which new temperature there are $10,000*N$ times of evolutions.

\subsection{SAVMP alogrithm pseudocode and complexity analysis }

The main steps of Simulated Annealing VM placement algorithm are quite
straightforward as described in Algorithm 1 below. As the energy
calculation needs $C*M$ times of computation, where $C$ is a const, the
complexity is $1,000*10,000*N*C*M$, which can be expressed as $O(N*M)$.

\begin{algorithm}[tbh]
\DontPrintSemicolon
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\caption{Simulated Annealing Virtual Machine Placement Algorithm}
\label{algorithm1}
\Input{VM requirements, PM capacities}
\Output{assignment of VMs to PMs}
	Generated Initial Assignment using FFD\;
	$Temperature\leftarrow 1000$ \;
	\While{ Temperature $>$ 0 }{
	Compute the $deviationEnergy$ allowed by the current
	                 temperature\;
	    \For{$i\leftarrow 1$ \KwTo $10000*N$ }{
	        Create a random neighbor placement\;
	        Calculate the incremental energy compared to previous placement\;
	        \eIf{ incremental energy $<$ 0}{
	               Set the placement as the new state\;	
	               Save the placement if it costs the least energy so far\;
	        }{
	             \eIf{ evolution in stalemate \KwSty{and} incremental energy $<\;
	             deviationEnergy$}{
	             	 Set the placement as the new state\;
	             	 } {}
	        }
	    }
	    Decrease $Temperature$\;
	}

\end{algorithm}

\section{Experiment and Evaluation}
\subsection{Methodology}
To test the performance of SAVMP, we design a series of tests with different
numbers of VMs to test how the proposed algorithm performs under different
problem sizes. For the same numbers of VMs, PM sizes are also varied to test the
impact of the container sizes on the performance of SAVMP. In addition to this,
we compare the energy cost of the VM placement decided by SAVMP to that by FFD (
the upper boundary) and the low boudary, which is calculated with fewer
constraints taken into account. What's more, the problems have two groups. In
one group of them, only CPU requirements are considered and in another the
memory requirements are added to test the performance of the SAVMP on
one-dimension and two-dimension packing respectively.

Specifically, VM numbers are 20, 50, 100 or 200. 
To show the size of their containers, the PMs, we introduce the Capacity
Index:
\begin{equation}\label{12}
CI=\frac{\sum_{j=1}^Mp_{cpu}^j / M}{\sum_{i=1}^N\max{(v_{cpu}^i)} / N} \\
\end{equation}
where $\max{(v_{cpu}^i)}$ is the maximum allowed CPU allocation for $v_i$. For
example, if an internal or external customer asks for a VM with 1000 MIPS (
million instructions per second) of CPU and 1GB of memory, the $\max{(v_{cpu}^i)}$ of
this VM will be 1000 in our problem formulation. When $CI$ is 1, that means the
number of PMs in the problem is the same as the number of VMs, and $CI=5$ means
the PM number is only one fifth of that of VMs, because one PM can host 5 VMs
averagely.
In the following experiment, for every VM size, CI values iterate in the set$
[1, 2, 3, 4, 5, 10]$ to form a new VM placement problem.
In one group of tests, we only consider CPU requirements to simulate the
situation in some data centers where most of the VMs are CPU intensive.
The VM CPU requirement is generated randomly from the value 0 to 2000. This is
to simulate the resource usage of the VMs at the data center at a sampling time.
The PM sizes vary from 1000 to 3000 multiplied by the CI (capacity index),
simulating the heterogeneous host environment. In another we add memory
requirements to test the performance of the SAVMP on one dimensional and two
dimensional packing respectively. The requirement of memory is generated in the
same way as CPU, but the two requirements are most probably not the same value
for the same VM because of the random nature.

Each PM's maximum energy $e_j$ is given by the equation:
\begin{equation}\label{13}
e_j=(1-\log (p_{cpu}^j/1000)*0.4)*E*(p_{cpu}^j/1000) \\
\end{equation}
Where E is a const, set to 100 Watt in our test, representing the base energy
which is consumed by the smallest PM when $p_{cpu}^j=1000$. When the CPU
capability is 10 times of the smallest PM, the energy cost is only 6 times as
much~\cite{Meikel08}. This equation reflects the energy saving method by
adopting larger physical machines.

For each physical server, the energy of idle status is set to 70\% of the
 maximum power, namely,
 \begin{equation}\label{14}
e_{idle}^j= e_{max}^j*0.7
\end{equation}

As to the initial placement, our proposed SAVMP does not require a specified
state. In the following tests, we choose to start from the placement results
generated by FFD, although SAVMP can achieve a comparable result from a random
feasible placement at the cost of more time according to our preliminary
tests.

For every configuration of VMs and PMs, we run ten times and average the 
percentage of the energy saving compared to FFD and the time to reach the best
placement among all the evolutions in order to have a statistical view of performance of the SAVMP
because it does not generate the exactly same result every time as FFD does for
the same problem. All the tests are run on a laptop with a 2.2G Hz dual core
processor.

As the best possible solution is not available to be compared with, we calculate
the low boundary of energy consumption to see how far the SAVMP result is from
the low boundary (LB). The LB is calculated by the way described in Algorithm 2,
which fills the most energy efficient PMs first, and otherwise finds a PM with
the lowest energy cost to accommodate the left CPU requirement. This energy
value is the low boundary because it does not consider the
constraints(7,8,9) and arrange the requirement to the most energy efficient PMs.
If an algorithm find a solution with the energy value very close to low boundary, we can say it is a very good result. However, it cannot
be concluded that an algorithm performs badly when its energy cost is far from
the LB, because the constraints may be the reason for the poor energy
efficiency. In such case we need other ways to analyze the placement results.
For example the table listing the resource utilization for all PMs may be very
useful to check whether the VMs are assigned in a energy efficient way.

\begin{algorithm}
\SetAlgoLined
\LinesNumbered
\caption{Low Boundary Energy Calculation}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{VM requirements, PM capacities}
\Output{energy low boundary}
	Sort the PM by CPU capacity by decreasing order \;
	$totalCPU\leftarrow \sum_{i=1}^Nv_{cpu}^i $ \;
	$leftCPU\leftarrow totalCPU$\;
	$totalEnergy\leftarrow 0$ \;
	$lastPMEnergy\leftarrow maximum\, integer$ \;	
	\For{$j\leftarrow 1$ \KwTo $M$ }{	
	        \eIf{ $p_{cpu}^j$ $<=$ $leftCPU$}{
	               $totalEnergy\leftarrow totalEnergy + e_j$ \;
	               $leftCPU\leftarrow leftCPU-p_{cpu}^j $ \;
	        }
	        {
	        	$energyOfthePM \leftarrow energy\, of\, p_j\, when\, workload\, is\,
	        	leftCPU$
	        	\;
	             \eIf{ $energyOfthePM$ $<$ $lastPMEnergy$}
	             {
	             	 $lastPMEnergy\leftarrow energyOfthePM $ \;
	             } { }
	        }
	}
	$totalEnergy\leftarrow totalEnergy + lastPMEnergy$ \;
\end{algorithm}
\subsection{Results of one-dimension packing}
Table 1 lists the testing results of FFD, SAVMP and the low boundary energy on
24 problems with different VM and PM numbers. Each problem has one row in the
table.  In the columns, `VM', `PM' show how many VMs and PMs are in the problems
respectively; CI is the capacity index, which is defined in Equation(12);
`Energy by FFD' is the energy cost if the VMs' assignment to PMs is decided by
the FFD algorithm; `Energy by SA', in which SA is the short format for SAVPM for
saving space, is the energy cost of the placement generated by SAVPM; `Energy
Saved' is calculated by $(1 - Energy\, by\, SA/Energy\, by\, FFD)*100\%$; `SA
from\% LB' is how many more percent of energy used by SAVMP than the low
boundary;`Time' is the time cost for SAVPM to find the `best' solution.
In this group of tests, only the CPU constraints(Equation 8) and the one VM
assigned to one PM assignment constraints(Equation 6) are considered. 

\begin{table*}[t]
\begin{center}
\caption{
Simulation test results of SAVMP on different numbers of VMs and
varied Capacity Indexes with only CPU constraints
}
\begin{tabular}
{c|c|c|c|c|c|c|c|c}
\hline\hline
VM (\#) & PM (\#) & CI & Energy by FFD (watt)  & Energy by SA (watt)  & Energy
Saved (\%) & Time (sec)  & LB (watt) & SA from LB (\%)\\
\hline
20 & 20 & 1 & 1691.8 & 1536.3 & 9.18 & 3.18 & 1422.7 & 7.39\\
20 & 10 & 2 & 1445.9 & 1351.1 & 6.56 & 0.62 & 1278.4 & 5.38\\
20 & 6  & 3 & 1491.2 & 1428.3 & 4.22 & 0.35 & 1423.5 & 0.34\\
20 & 5  & 4 & 1341.8 & 1271.8 & 5.21 & 1.16 & 1196.7 & 5.91\\
20 & 4  & 5 & 1374.9 & 1339.3 & 2.59 & 0.60 & 1296.1 & 3.23\\
20 & 2  &10 & 1219.1 & 1219.0 & 0.01 & 0.94 & 1102.0 & 9.60\\
\hline
50 & 50 &1 & 4283.5 & 4040.8 & 5.40 & 28.42 & 4032.3 & 0.21\\
50 & 25 &2 & 3615.0 & 3507.1 & 2.99 & 2.21 & 3470.1 & 1.05\\
50 & 16 &3 & 3297.5 & 3188.0 & 3.33 & 6.25 & 3119.6 & 2.15\\
50 & 12 &4 & 3005.0 & 3004.7 & 0.01 & 0.42 & 2710.9 & 9.78\\
50 & 10 &5 & 2839.3 & 2839.1 & 0.01 & 0.54 & 2487.7 & 12.38\\
50 & 5  &10 & 2576.9 & 2576.7 & 0.01 & 0.98 & 2275.4 & 11.69\\
\hline
100 &100 & 1 & 9399.5 & 8654.4 & 8.12 & 282.22 & 8461.6 & 2.23\\
100 &50  & 2 & 7444.7 & 7327.9 & 1.10 & 49.02 & 7296.2 & 0.43\\
100 &33  & 3 & 6880.4 & 6728.9 & 2.20 & 8.45 & 6726.5 & 0.04\\
100 &25  & 4 & 6471.1 & 6112.6 & 5.54 & 0.61 & 5774.6 & 5.53\\
100 &20  & 5 & 5774.0 & 5773.6 & 0.01 & 20.11 & 5405.2 & 6.38\\
100 &10  & 10 & 4510.5 & 4510.3 & 0.00 & 1.01 & 3903.6 & 13.45\\
\hline
200 &200 & 1 & 18234.2 & 16837.6 & 7.99 & 1830.65 & 16446.3 & 2.32\\
200 &100 & 2 & 14516.2 & 14269.8 & 1.94 & 1952.39 & 14120.1 & 1.05\\
200 &66  & 3 & 13001.2 & 12853.7 & 0.57 & 170.54 & 12824.6 & 0.23\\
200 &50  & 4 & 11846.3 & 11845.3 & 0.01 & 51.37 & 11538.8 & 2.59\\
200 &40  & 5 & 11447.5 & 11269.3 & 1.68 & 23.09 & 10558.2 & 6.31\\
200 &20  & 10 & 8941.6 & 8941.3 & 0.00 & 27.71 & 8462.3 & 5.36\\
\hline\hline
\end{tabular}
\end{center}
\end{table*}

From Table 1 , we can see SAVMP is able to generate
better results than FFD for most of the situations and at least no worse than FFD for all the tests.
This may partially attribute to starting from the FFD placement, but this also
shows one of its good characteristics of starting from any feasible placement
and improving it little by little.

However, the improvement by SAVMP varies with the VM numbers and CI. The larger
is the VM number or CI, the less is the improvement. This can be attributed to 2
possible reasons. One is that with the larger number of VMs and PMs, the search
space becomes larger; another one is that the performance of FFD varies on the
different problems. For example, in Table 2, the placement results reveal that
FFD can have a very good result when the VM number is 200 and CI is 10. `PM' column in Table 2
is the PM index number, representing one physical machine in the problem; `Size'
is the CPU capacity; `CPU utilization' is CPU utilization rate in percentage
when a certain number of VMs are assigned to the PM. Some PMs are not assigned any VMs so the CPU usage is
0.00\%.

The energy saving improvement by SAVMP above FFD in this group of tests is not
very significant, with only averagely about 5\% better than the latter, because for the CPU only
constraint problem, FFD can generate a very good result, which can be seen by
comparing the energy of FFD and that of LB.

Almost all the tests can achieve the best results among all the iterations in
less than 100 seconds. For the tests with exceptionally long time to reach the
`best' results, we find that they can achieve very good results close to
the ``best'' result within 100 seconds after looking into the evolution
history records.


\begin{table}[h]
\begin{center}
\caption{VM placement results by FFD on 200 VMs
 with capacity index of 10}
$\begin{tabular}{c|c|c}
\hline\hline
PM Index & Size & CPU Utilization (\%) \\
\hline
1 & 30000 & 99.67\\
2 & 30000 & 99.67\\
3 & 27000 & 99.63 \\
4 & 27000 & 99.63 \\
5 & 25000 & 99.60 \\
6 & 25000 & 99.60\\
7 & 24000 & 99.58 \\
8 & 24000 & 48.33 \\
9 & 23000 & 0.00 \\
10 & 23000 & 0.00 \\
11 & 20000 & 0.00 \\
12 & 20000 & 0.00\\
13 & 18000 & 0.00\\
14 & 18000 & 0.00\\
15 & 15000 & 0.00\\
16 & 15000 & 0.00\\
17 & 12000 & 0.00\\
18 & 12000 & 0.00\\
19 & 10000 & 0.00\\
20 & 10000 & 0.00\\
\hline\hline
\end{tabular}$
\end{center}
\end{table}
\subsection{Results of two-dimension packing}
While the improvement by SAVMP for the one dimension packing problem is small,
the results on the 2 dimension packing show the SAVMP performs significantly
better than FFD. In Table 3, which contains the results by FFD and SAVMP with
CPU and memory constraints, the columns are the same as in Table 1 except that
there is an extra `Energy saved by Random Search' column in Table 3, which
is the energy saving effects achieved by a Random Search (RS) method. In this
method, a PM is picked randomly for each VM. If the chosen PM does not satisfy the
constraints, it will try another randomly chosen PM until it finds a suitable
one or gives up searching and returns no feasible solution after the maximum
attempts have been used. The same process repeats until all the VMs have their
assigned PMs. To be fair, the number of iterations of RS is the same as SAVMP. 

The Random Searching's performance is comparable to SAVMP when there are only 20
VMs. However, when the VM number increases, the energy saving improvement
becomes less or even zero. This is especially obvious when the number is greater
than 50.
The Random Search can only improve by a small percentage to FFD when CI is 5 or 10. In all
tests but the one of which the VM number is 20 and CI is 5, the Random Search
performs worse than SAVMP.

The random searching results show that the SAVMP performs better than FFD
not only because it involves random searching method to explore more assignment
combinations than FFD, but also because the Simulation Annealing approach
provides a evolutionary search more than random attempts.

The distances of SAVMP from the Low Boundary are averagely within 10 percent,
which says the simulated annealing algorithm has achieved very good energy
saving results.

The improvement effect by SAVMP for two constraints is more significant than
that for only CPU constraint. When the VM number becomes larger, the improvement
tends to be less because the searching space grows bigger. The relationship of
the improvement and CI is not straightforward. It has two contradictory effects
on the improvement by SAVMP. For one thing, the larger the CI is, the smaller
the searching space becomes. The smaller searching space favors SAVMP but FFD
also performs better than when CI is smaller.

From the table, we can find another benefit of using SAVMP in the test of which
the VM number is 20 and CI is 10. FFD or Random Search cannot find a feasible
solution for this test, but SAVMP can find the feasible assignment successfully.

%Table3 :

\begin{table*}[t]
\begin{center}
\begin{threeparttable}

\caption{Simulation test results of SAVMP on different numbers of VMs and varied
Capacity Indexes with CPU and Memory constraints}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c}
\hline\hline
 VM & PM & CI & Energy by FFD&Energy by SA&Time&Energy
 Saved by SA&Energy Saved by RS& LB & SA from LB\\
 (\#) & (\#) &  & (watt) & (watt)& (sec) & (\%) & (\%) &  &(\%) \\
\hline
20 &20 & 1 & 2090.7 & 1774.1 & 3.20 & 15.79 & 9.23 & 1422.7 & 19.80\\
20 &10 & 2 & 1682.7 & 1445.5 & 1.54 & 14.13 & 8.35 & 1278.4 & 11.56\\
20 &6 & 3 & 1688.9 & 1429.2 & 1.24 & 15.37 & 13.91 & 1423.5 & 0.40\\
20 &5 & 4 & 1800.3 & 1341.6 & 0.52 & 25.48 & 24.45 & 1196.7 & 10.80\\
20 &4 & 5 & 1627.7 & 1339.3 & 1.32 & 16.84 & 17.40 & 1296.1 & 3.23\\
20 &2 & 10 & N/A\tnote{a} & 1219.0 & 0.94 & N/A\tnote{a} & N/A\tnote{a} &
1102.0 & 9.60\\
\hline
50 &50 & 1 & 4834.7 & 4310.9 & 28.92 & 10.19 & 0.17 & 4062.3 & 5.77\\
50 &25 & 2 & 4256.4 & 3616.8 & 7.45 & 15.15 & 5.81 & 3470.1 & 4.06\\
50 &16 & 3 & 3856.6 & 3298.8 & 1.73 & 14.47 & 7.02 & 3119.6 & 5.43\\
50 &12 & 4 & 3365.2 & 3006.5 & 0.72 & 10.67 & 3.82 & 2710.9 & 9.83\\
50 &10 & 5 & 3304.5 & 2840.8 & 0.64 & 14.04 & 11.43 & 2487.7 & 12.43\\
50 &5 & 10 & 3057.3 & 2578.2 & 1.09 & 15.68 & 15.65 & 2275.4 & 11.75\\
\hline
100 &100 & 1 & 9404.8 & 8871.7 & 131.53 & 5.41 & 0 & 8461.6 & 4.62\\
100 &50 & 2 & 8159.5 & 7448.1 & 44.51 & 8.78 & 0 & 7296.2 & 2.04\\
100 &33 & 3 & 7494.9 & 6813.5 & 25.86 & 9.08 & 0.57 & 6726.5 & 1.28\\
100 &25 & 4 & 6835.5 & 6116.3 & 7.78 & 10.53 & 0 & 5774.6 & 5.59\\
100 &20 & 5 & 6704.9 & 5777.0 & 2.04 & 13.85 & 6.37 & 5405.2 & 6.44\\
100 &10 & 10 & 5247.0 & 4513.0 & 1.85 & 14.00 & 7.41 & 3903.6 & 13.50\\
\hline
200 &200 & 1 & 18373.2 & 17379.2 & 1250.81 & 5.46 & 0 & 16446.3 & 5.37\\
200 &100 & 2 & 15944.7 & 14514.2 & 208.13 & 8.29 & 0 & 14120.1 & 2.72\\
200 &66  & 3 & 14606.7 & 12999.5 & 215.01 & 10.14 & 0 & 12824.6 & 1.35\\
200 &50  & 4 & 13442.6 & 12253.2 & 22.45 & 8.85 & 0 & 11538.8 & 5.83\\
200 &40  & 5 & 12375.4 & 11446.7 & 17.41 & 7.50 & 1.66 & 10558.2 & 7.76\\
200 &20  & 10 & 9675.6 & 8941.3 & 23.50 & 7.59 & 5.61 & 8462.3 & 5.36\\
\hline\hline
\end{tabular}
\begin{tablenotes}
\item [a] For VM number=2 and CI=10 with CPU and memory constraints, FFD cannot
provide a feasible solution, so the ``Energy Saved'' value is not applicable.
\end{tablenotes}
\end{threeparttable}

\end{center}
\end{table*}

%*Note: For VM number=2 and CI=10 with CPU and memory constraints, FFD cannot
%provide a feasible solution, so the ``Energy Saved'' value is not applicable.


It is probably impossible to determine the minimum energy usage among all the
possible assignment, but we can use the resource utilization on the PMs resulted from the
VM assignment besides the low boundary to examine and compare the energy saving
effect of different algorithms. In Table 4, the utilization of CPU and memory
has been listed for each PM for the test of 200 VMs with CI set to 10 applying FFD and
SAVMP respectively. It is clear from the table that SAVMP achieve higher
resource utilization with 2 less PMs turned on than FFD, leaving very small
room for to be improved if there is any.

%Table 4 -
\begin{table*}[htb!]
\caption{PM resource utilization Comparison between placement by FFD and SAVMP
on 200 VMs with capacity index = 10}
\begin{center}
$\begin{tabular}{c|c|c|c|c|c}
\hline\hline
 &  & \multicolumn{2}{c|}{FFD}&\multicolumn{2}{|c}{SAVMP} \\
 \cline{3-6}
PM Index & Size & CPU Utilization (\%) & Memory Utilization (\%) & CPU Utilization (\%)& Memory Utilization (\%)\\
\hline
1 & 30000 & 99.83 & 54.00 & 100.00 & 79.00\\
2 & 30000 & 99.83 & 58.67 & 100.00 & 96.67\\
3 & 27000 & 99.81 & 75.93 & 100.00 & 82.96\\
4 & 27000 & 99.81 & 57.04 & 100.00 & 78.15\\
5 & 25000 & 99.80 & 83.20 & 99.80 & 99.20\\
6 & 25000 & 99.80 & 94.00 & 99.80 & 98.40\\
7 & 24000 & 80.00 & 99.58 & 74.79 & 85.00\\
8 & 24000 & 51.25 & 99.58 & 73.33 & 91.25\\
9 & 23000 & 18.04 & 99.57 & 0.00 & 0.00\\
10 & 23000 & 0.43 & 13.91 & 0.00 & 0.00\\
11 & 20000 & 0.00 & 0.00 & 0.00 & 0.00\\
12 & 20000 & 0.00 & 0.00 & 0.00 & 0.00\\
13 & 18000 & 0.00 & 0.00 & 0.00 & 0.00\\
14 & 18000 & 0.00 & 0.00 & 0.00 & 0.00\\
15 & 15000 & 0.00 & 0.00 & 0.00 & 0.00\\
16 & 15000 & 0.00 & 0.00 & 0.00 & 0.00\\
17 & 12000 & 0.00 & 0.00 & 0.00 & 0.00\\
18 & 12000 & 0.00 & 0.00 & 0.00 & 0.00\\
19 & 10000 & 0.00 & 0.00 & 0.00 & 0.00\\
20 & 10000 & 0.00 & 0.00 & 0.00 & 0.00\\
\hline\hline
\end{tabular}$

\end{center}
\end{table*}

Comparation of the results in Table 1 and Table 3 shows that SAVMP can generate
better energy-efficient VM placment than FFD in both one-dimension and
two-dimension bin-packing problems. The time for searching the `best' results
remmains the same for the both. Further, power usage of
the two-dimension problems is more than that of the one dimension ones because
more constraints lead to more use of resources to accmodate the requirement.
However, this leaves more room for SAVMP to improve the energy saving above FFD. 
%\begin{center}
%Table 5
%\end{center}

\section{Conclusion and Future work}

We propose SAVMP - a VM placement algorithm based on Simulated Annealing theory
to improve energy efficiency in data centers. This is the first published
attempt of using SA based algorithms to solve the VM placement problem for
better energy efficiency. Its performance is compared with that of FFD and
Random Searching.
Extensive experiment has been done with different problem configurations. The
number of VMs varies from 20 to 200, the sizes of the PMs are from one to 10
times of maximum requirement of VMs, and resource constraints are CPU only - one
dimensional, and CPU combined with memory - two dimensions.

Experiment results show that SAVMP can generate better VM assignment than FFD,
especially in the two dimensional constraint problems with 0-25\% more energy
saving than FFD. How much improvement it can make from the FFD depends largely
on the room FFD leaves for improvement. SAVMP can generate VM placement that
costs the energy very close to the low boundary.

When the problem size grows larger, the time needed to find the `best' solution
can be large, but within resonable time limit, SAVMP can get a result very
close to the `best' result. The algorithm has a good attribute of being stopped
at any time and providing the best result achieved so far.

It can also be concluded from the comparison between SAVMP and Random
Searching that SAVMP is the more efficient search strategy guided by target
objective than random searching. SAVPM can improve energy saving in all the tests, while
Random Search can only do so for small-scale problems and less significantly
over all.

Besides the more effective optimization result, the SAVMP has another benefit:
it generates multiple placements that have better optimization result than FFD.
This makes the algorithm potential to be used in the dynamic VM allocation to
minimize the migration cost while saving energy. In our future work we will
attempt using SAVMP in live VM migration solutions and compare its effectiveness
with existing solutions.

\section*{Acknowledgment}
This research is partially funded by Division of Trichology, Information and
Learning Support of QUT.
During the research process, Don Caruana, Adrian Yarrow and Mohammad Hassan 
generously shared their expertise on data center management and 
energy consumption containment.

%\newpage

\bibliographystyle{IEEETran}
\bibliography{paper1}

\end{document} 